1) Explique que es y para que sirve un constructor por copia en C++.
      A) indique como se comporta el sistema si no esta definido por el desarrollador.
      B) Explique al menos una estrategia para evitar que una clase particular sea copiable.
      C) Indique que diferencia hay entre un constructor por copia y uno por movimiento.

-) Un constructor por copia genera una copia exacta de otro objeto de la misma clase. Es decir, construye un nuevo objeto que es una copia del que recibe por parametro, copiando sus atributos.
  A) Si no esta definido por el desarrollador, se crea un constructor por copia default, que es una copia bit a bit del objeto recibido. Si hay un atributo que tiene su constructor por copia eliminado, no se puede crear un constructor default.
  B) Para hacer que una clase particular no sea copiable, podemos eliminar el constructor por copia y el operador =, haciendo uso del keyword delete. Ej: ClaseA(const ClaseA& other) = delete;
  C) La diferencia entre un constructor por copia y uno por movimiento es que el constructor por copia genera una copia exacta del objeto que recibe por parametro y sin modificar el objeto que recibe. En cambio, un constructor por movimiento lo que hace es "adueñarse" de los recursos del objeto que recibe por parametro, como por ejemplo memoria en el Heap. Esta diferencia es muy importante en casos donde tenemos un objeto que encapsula un recurso utilizando RAII. Si tuviemos un objeto que encapsula memoria en el heap utilizando RAII, y creamos una copia del mismo, se puede dar el caso donde tenemos accesos a memoria liberada o double free ya que cuando uno de esos objetos se destruya se libera el recurso, pero la otra instancia no sabe de esto por lo que puede intentar liberarla o accederla. En esos casos deberiamos utilizar el movimiento, ya que hace que el nuevo objeto sea el dueño del recurso, e invalidando el recurso para la instancia recibida por parametro.


3) Describa con exactitud las siguientes declaraciones/definiciones globales.
 - void (*f)(int i) -> Definicion de un puntero a una funcion que recibe por parametro un entero y no devuelve nada. Al ser global, reside en el data segment y es visible para todos los modulos.
 - static void B(float a, float b){} -> Definicion de una función que no devuelve nada y recibe por parametro dos floats. Reside en el code segment y al tener el keyword static es unicamente visible en el modulo donde se declara.
 - int* (*C)[5] -> Definición de un array de 5 punteros a funciones que devuelven un entero. Reside en el data segment y es visible para todos los modulos.


6) ¿Que es una macro de C? Describa las buenas practicas para su definicion y ejemplifique.
-) Una macro de C es una directiva de pre-procesador bajo la cual le asigno un nombre a una seccion de código. Luego, durante el pre-procesamiento, el compilador reeplazara todas las apariciones del nombre de la macro por el cuerpo (código) que le hayamos asignado. Por ejemplo #define CANTIDAD_MAXIMA 5, crea una macro de nombre CANTIDAD_MAXIMA cuyo cuerpo es 5, por lo que luego se reemplazaran todas las apariciones de CANTIDAD_MAXIMA por el 5. Es buena practica utilizar macros para las constantes que no vayan a cambiar durante la ejecución del programa (Ej. Tamaño maximo de un buffer). Tambien deberiamos asignarles, como a las variables, nombres descriptivos para aumentar la legibilidad del código. Si la macro se expande en una expresion, por ejemplo, a+b, es buena práctica encerrar la expresion en parentesis, ya que si utilizara en una expresion matematica puede crear ambiguedad. Ademas, podemos crear macros que aumenten la legibilidad de algunas expresiones como
"int max = a > b ? a : b;" utilizando macros como #define MAX(a,b) (a > b ? a : b), por lo que el código quedaria mas legible de la forma int max = MAX(a,b);

8) Describa el proceso de transformación de codigo fuente a un ejecutable. Precise las etapas, tareas desarrolladas y los tipos de error generados.
-) Inicialmente, el código es sometido a la etapa de pre-procesamiento en donde se expanden las macros utilizadas y son ejecutadas las directivas de pre-procesador como por ejemplo los #include. Luego, el código pasa por el proceso de compilación, donde se transforma el código fuente a código objeto. Esta etapa puede traer errores de compilación, en donde utilizamos variables y/o funciones que no fueron declaradas por el desarrollador que son necesarias para la compilación del codigo. Por ultimo, esta la etapa de link-edicion, en donde se juntan todos los códigos objetos generados en el proceso de compilación y se los "une" en un único archivo. Este proceso puede traer problemas de linkeo, en donde hay variables o funciones que fueron declaradas pero no definidas, por lo cual el linker no puede concluir exitosamente.

9) ¿Que ventajas tiene un lock RAII frente al tradicional lock/unlock?
-) Un lock RAII tiene como ventaja que, si se utiliza en conjunto con el stack, hace imposible que el lock no se libere, ya que eventualmente ese objeto se va a destruir y el destructor libera el recurso asociado, mientras que el tradicion lock/unlock inserta la posibilidad de que el desarrollador se olvide de liberar el recurso, por lo cual el lock nunca seria desbloqueado. Ademas, una ventaja muy importante de un lock RAII es que es seguro frente a excepciones, es decir, si existiese una excepcion entre que se adquiere el recurso y se libera, al tener el lock en el stack, C++ nos garantiza que se va a a llamar a los destructores de los objetos creados, entre ellos el lock RAII, que liberaria el recurso en su destructor. En cambio, en el tradicional lock/unlock esto no se puede hacer con excepciones que no son manejadas ya que nunca se llegaria al código que libera el recurso.

10) ¿Que significa que una función sea bloqueante? ¿Como subsanaria esa limitación en terminos de mantener al programa vivo?
-) Que una funcion sea bloqueante significa que el hilo en el cual se llamo a esa función queda a la espera de que dicha funcion termine de ejecutarse para poder seguir. Esto normalmente para funciones cortas o rapidas no trae problemas, pero si tenemos funciones que demoran mucho tiempo o dependen de un evento externo para finalizar (Ej. La funcion accept para aceptar conexiones entrantes) esto genera que el programa quede bloqueado a la espera de que esto finalize. Para mantener el programa vivo lo que se debe hacer es hacer que estas funciones se ejecuten en un hilo aparte, habilitando al hilo principal a seguir con la ejecución de otras instrucciones. Luego, se pueden unir los hilos utilizando la funcion join. Esto nos permite que el programa siga vivo mientras la funcion bloqueante corre en otro hilo aparte.
